# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T14:15:03+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyHeader, BaseSecurity
from fastapi import Header, Path, Query
from pydantic import conint, constr

from models import (
    AccessDeniedException,
    ConflictException,
    CreateLensShareOutput,
    CreateLensVersionOutput,
    CreateMilestoneOutput,
    CreateWorkloadOutput,
    CreateWorkloadShareOutput,
    ExportLensOutput,
    Format,
    GetAnswerOutput,
    GetConsolidatedReportOutput,
    GetLensOutput,
    GetLensReviewOutput,
    GetLensReviewReportOutput,
    GetLensVersionDifferenceOutput,
    GetMilestoneOutput,
    GetWorkloadOutput,
    GlobalSettingsPatchRequest,
    ImportLensOutput,
    ImportLensPutRequest,
    InternalServerException,
    LensesLensAliasSharesPostRequest,
    LensesLensAliasVersionsPostRequest,
    LensStatus1,
    LensType,
    ListAnswersOutput,
    ListCheckDetailsOutput,
    ListCheckSummariesOutput,
    ListLensesOutput,
    ListLensReviewImprovementsOutput,
    ListLensReviewsOutput,
    ListLensSharesOutput,
    ListMilestonesOutput,
    ListNotificationsOutput,
    ListShareInvitationsOutput,
    ListTagsForResourceOutput,
    ListWorkloadSharesOutput,
    ListWorkloadsOutput,
    NotificationsPostRequest,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    ShareInvitationsShareInvitationIdPatchRequest,
    ShareResourceType,
    Status,
    TagKeys,
    TagResourceOutput,
    TagsWorkloadArnPostRequest,
    ThrottlingException,
    UntagResourceOutput,
    UpdateAnswerOutput,
    UpdateLensReviewOutput,
    UpdateShareInvitationOutput,
    UpdateWorkloadOutput,
    UpdateWorkloadShareOutput,
    ValidationException,
    WorkloadsPostRequest,
    WorkloadsSummariesPostRequest,
    WorkloadsWorkloadIdAssociateLensesPatchRequest,
    WorkloadsWorkloadIdChecksPostRequest,
    WorkloadsWorkloadIdCheckSummariesPostRequest,
    WorkloadsWorkloadIdDisassociateLensesPatchRequest,
    WorkloadsWorkloadIdLensReviewsLensAliasAnswersQuestionIdPatchRequest,
    WorkloadsWorkloadIdLensReviewsLensAliasPatchRequest,
    WorkloadsWorkloadIdLensReviewsLensAliasUpgradePutRequest,
    WorkloadsWorkloadIdMilestonesPostRequest,
    WorkloadsWorkloadIdMilestonesSummariesPostRequest,
    WorkloadsWorkloadIdPatchRequest,
    WorkloadsWorkloadIdSharesPostRequest,
    WorkloadsWorkloadIdSharesShareIdPatchRequest,
)

app = MCPProxy(
    contact={
        'email': 'mike.ralphson@gmail.com',
        'name': 'Mike Ralphson',
        'url': 'https://github.com/mermade/aws2openapi',
        'x-twitter': 'PermittedSoc',
    },
    description='<fullname>Well-Architected Tool</fullname> <p>This is the <i>Well-Architected Tool API Reference</i>. The WA Tool API provides programmatic access to the <a href="http://aws.amazon.com/well-architected-tool">Well-Architected Tool</a> in the <a href="https://console.aws.amazon.com/wellarchitected">Amazon Web Services Management Console</a>. For information about the Well-Architected Tool, see the <a href="https://docs.aws.amazon.com/wellarchitected/latest/userguide/intro.html">Well-Architected Tool User Guide</a>.</p>',
    license={'name': 'Apache 2.0 License', 'url': 'http://www.apache.org/licenses/'},
    termsOfService='https://aws.amazon.com/service-terms/',
    title='AWS Well-Architected Tool',
    version='2020-03-31',
    servers=[
        {
            'description': 'The Well-Architected multi-region endpoint',
            'url': 'http://wellarchitected.{region}.amazonaws.com',
            'variables': {
                'region': {
                    'default': 'us-east-1',
                    'description': 'The AWS region',
                    'enum': [
                        'us-east-1',
                        'us-east-2',
                        'us-west-1',
                        'us-west-2',
                        'us-gov-west-1',
                        'us-gov-east-1',
                        'ca-central-1',
                        'eu-north-1',
                        'eu-west-1',
                        'eu-west-2',
                        'eu-west-3',
                        'eu-central-1',
                        'eu-south-1',
                        'af-south-1',
                        'ap-northeast-1',
                        'ap-northeast-2',
                        'ap-northeast-3',
                        'ap-southeast-1',
                        'ap-southeast-2',
                        'ap-east-1',
                        'ap-south-1',
                        'sa-east-1',
                        'me-south-1',
                    ],
                }
            },
        },
        {
            'description': 'The Well-Architected multi-region endpoint',
            'url': 'https://wellarchitected.{region}.amazonaws.com',
            'variables': {
                'region': {
                    'default': 'us-east-1',
                    'description': 'The AWS region',
                    'enum': [
                        'us-east-1',
                        'us-east-2',
                        'us-west-1',
                        'us-west-2',
                        'us-gov-west-1',
                        'us-gov-east-1',
                        'ca-central-1',
                        'eu-north-1',
                        'eu-west-1',
                        'eu-west-2',
                        'eu-west-3',
                        'eu-central-1',
                        'eu-south-1',
                        'af-south-1',
                        'ap-northeast-1',
                        'ap-northeast-2',
                        'ap-northeast-3',
                        'ap-southeast-1',
                        'ap-southeast-2',
                        'ap-east-1',
                        'ap-south-1',
                        'sa-east-1',
                        'me-south-1',
                    ],
                }
            },
        },
        {
            'description': 'The Well-Architected endpoint for China (Beijing) and China (Ningxia)',
            'url': 'http://wellarchitected.{region}.amazonaws.com.cn',
            'variables': {
                'region': {
                    'default': 'cn-north-1',
                    'description': 'The AWS region',
                    'enum': ['cn-north-1', 'cn-northwest-1'],
                }
            },
        },
        {
            'description': 'The Well-Architected endpoint for China (Beijing) and China (Ningxia)',
            'url': 'https://wellarchitected.{region}.amazonaws.com.cn',
            'variables': {
                'region': {
                    'default': 'cn-north-1',
                    'description': 'The AWS region',
                    'enum': ['cn-north-1', 'cn-northwest-1'],
                }
            },
        },
    ],
)


@app.get(
    '/consolidatedReport#Format',
    description=""" <p>Get a consolidated report of your workloads.</p> <p>You can optionally choose to include workloads that have been shared with you.</p> """,
    tags=['workload_operations', 'lens_sharing_operations', 'lens_review_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_consolidated_report(
    format: Format = Query(..., alias='Format'),
    include_shared_resources: Optional[bool] = Query(
        None, alias='IncludeSharedResources'
    ),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    max_results: Optional[conint(ge=1, le=15)] = Query(None, alias='MaxResults'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/global-settings',
    description=""" Updates whether the Amazon Web Services account is opted into organization sharing features. """,
    tags=['lens_version_control'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_global_settings(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GlobalSettingsPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/importLens',
    description=""" <p>Import a new custom lens or update an existing custom lens.</p> <p>To update an existing custom lens, specify its ARN as the <code>LensAlias</code>. If no ARN is specified, a new custom lens is created.</p> <p>The new or updated lens will have a status of <code>DRAFT</code>. The lens cannot be applied to workloads or shared with other Amazon Web Services accounts until it's published with <a>CreateLensVersion</a>.</p> <p>Lenses are defined in JSON. For more information, see <a href="https://docs.aws.amazon.com/wellarchitected/latest/userguide/lenses-format-specification.html">JSON format specification</a> in the <i>Well-Architected Tool User Guide</i>.</p> <p>A custom lens cannot exceed 500 KB in size.</p> <note> <p> <b>Disclaimer</b> </p> <p>Do not include or gather personal identifiable information (PII) of end users or other identifiable individuals in or via your custom lenses. If your custom lens or those shared with you and used in your account do include or collect PII you are responsible for: ensuring that the included PII is processed in accordance with applicable law, providing adequate privacy notices, and obtaining necessary consents for processing such data.</p> </note> """,
    tags=['lens_version_control', 'lens_sharing_operations', 'workload_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def import_lens(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ImportLensPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/lenses',
    description=""" List the available lenses. """,
    tags=['lens_version_control'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_lenses(
    next_token: Optional[str] = Query(None, alias='NextToken'),
    max_results: Optional[conint(ge=1, le=50)] = Query(None, alias='MaxResults'),
    lens_type: Optional[LensType] = Query(None, alias='LensType'),
    lens_status: Optional[LensStatus1] = Query(None, alias='LensStatus'),
    lens_name: Optional[constr(min_length=1, max_length=128)] = Query(
        None, alias='LensName'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/lenses/{LensAlias}',
    description=""" Get an existing lens. """,
    tags=['lens_version_control', 'lens_review_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_lens(
    lens_alias: constr(min_length=1, max_length=128) = Path(..., alias='LensAlias'),
    lens_version: Optional[constr(min_length=1, max_length=32)] = Query(
        None, alias='LensVersion'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/lenses/{LensAlias}#ClientRequestToken&LensStatus',
    description=""" <p>Delete an existing lens.</p> <p>Only the owner of a lens can delete it. After the lens is deleted, Amazon Web Services accounts and users that you shared the lens with can continue to use it, but they will no longer be able to apply it to new workloads. </p> <note> <p> <b>Disclaimer</b> </p> <p>By sharing your custom lenses with other Amazon Web Services accounts, you acknowledge that Amazon Web Services will make your custom lenses available to those other accounts. Those other accounts may continue to access and use your shared custom lenses even if you delete the custom lenses from your own Amazon Web Services account or terminate your Amazon Web Services account.</p> </note> """,
    tags=['lens_version_control', 'lens_review_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_lens(
    lens_alias: constr(min_length=1, max_length=128) = Path(..., alias='LensAlias'),
    client_request_token: str = Query(..., alias='ClientRequestToken'),
    lens_status: LensStatus1 = Query(..., alias='LensStatus'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/lenses/{LensAlias}/export',
    description=""" <p>Export an existing lens.</p> <p>Only the owner of a lens can export it. Lenses provided by Amazon Web Services (Amazon Web Services Official Content) cannot be exported.</p> <p>Lenses are defined in JSON. For more information, see <a href="https://docs.aws.amazon.com/wellarchitected/latest/userguide/lenses-format-specification.html">JSON format specification</a> in the <i>Well-Architected Tool User Guide</i>.</p> <note> <p> <b>Disclaimer</b> </p> <p>Do not include or gather personal identifiable information (PII) of end users or other identifiable individuals in or via your custom lenses. If your custom lens or those shared with you and used in your account do include or collect PII you are responsible for: ensuring that the included PII is processed in accordance with applicable law, providing adequate privacy notices, and obtaining necessary consents for processing such data.</p> </note> """,
    tags=['lens_version_control'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def export_lens(
    lens_alias: constr(min_length=1, max_length=128) = Path(..., alias='LensAlias'),
    lens_version: Optional[constr(min_length=1, max_length=32)] = Query(
        None, alias='LensVersion'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/lenses/{LensAlias}/shares',
    description=""" List the lens shares associated with the lens. """,
    tags=['lens_sharing_operations', 'lens_version_control'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_lens_shares(
    lens_alias: constr(min_length=1, max_length=128) = Path(..., alias='LensAlias'),
    shared_with_prefix: Optional[constr(max_length=100)] = Query(
        None, alias='SharedWithPrefix'
    ),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    max_results: Optional[conint(ge=1, le=50)] = Query(None, alias='MaxResults'),
    status: Optional[Status] = Query(None, alias='Status'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/lenses/{LensAlias}/shares',
    description=""" <p>Create a lens share.</p> <p>The owner of a lens can share it with other Amazon Web Services accounts, users, an organization, and organizational units (OUs) in the same Amazon Web Services Region. Lenses provided by Amazon Web Services (Amazon Web Services Official Content) cannot be shared.</p> <p> Shared access to a lens is not removed until the lens invitation is deleted.</p> <p>If you share a lens with an organization or OU, all accounts in the organization or OU are granted access to the lens.</p> <p>For more information, see <a href="https://docs.aws.amazon.com/wellarchitected/latest/userguide/lenses-sharing.html">Sharing a custom lens</a> in the <i>Well-Architected Tool User Guide</i>.</p> <note> <p> <b>Disclaimer</b> </p> <p>By sharing your custom lenses with other Amazon Web Services accounts, you acknowledge that Amazon Web Services will make your custom lenses available to those other accounts. Those other accounts may continue to access and use your shared custom lenses even if you delete the custom lenses from your own Amazon Web Services account or terminate your Amazon Web Services account.</p> </note> """,
    tags=['lens_sharing_operations', 'lens_version_control'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_lens_share(
    lens_alias: constr(min_length=1, max_length=128) = Path(..., alias='LensAlias'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: LensesLensAliasSharesPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/lenses/{LensAlias}/shares/{ShareId}#ClientRequestToken',
    description=""" <p>Delete a lens share.</p> <p>After the lens share is deleted, Amazon Web Services accounts, users, organizations, and organizational units (OUs) that you shared the lens with can continue to use it, but they will no longer be able to apply it to new workloads.</p> <note> <p> <b>Disclaimer</b> </p> <p>By sharing your custom lenses with other Amazon Web Services accounts, you acknowledge that Amazon Web Services will make your custom lenses available to those other accounts. Those other accounts may continue to access and use your shared custom lenses even if you delete the custom lenses from your own Amazon Web Services account or terminate your Amazon Web Services account.</p> </note> """,
    tags=['lens_sharing_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_lens_share(
    share_id: constr(pattern=r'[0-9a-f]{32}') = Path(..., alias='ShareId'),
    lens_alias: constr(min_length=1, max_length=128) = Path(..., alias='LensAlias'),
    client_request_token: str = Query(..., alias='ClientRequestToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/lenses/{LensAlias}/versionDifference',
    description=""" Get lens version differences. """,
    tags=['lens_version_control'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_lens_version_difference(
    lens_alias: constr(min_length=1, max_length=128) = Path(..., alias='LensAlias'),
    base_lens_version: Optional[constr(min_length=1, max_length=32)] = Query(
        None, alias='BaseLensVersion'
    ),
    target_lens_version: Optional[constr(min_length=1, max_length=32)] = Query(
        None, alias='TargetLensVersion'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/lenses/{LensAlias}/versions',
    description=""" <p>Create a new lens version.</p> <p>A lens can have up to 100 versions.</p> <p>Use this operation to publish a new lens version after you have imported a lens. The <code>LensAlias</code> is used to identify the lens to be published. The owner of a lens can share the lens with other Amazon Web Services accounts and users in the same Amazon Web Services Region. Only the owner of a lens can delete it. </p> """,
    tags=['lens_version_control', 'lens_sharing_operations', 'lens_review_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_lens_version(
    lens_alias: constr(min_length=1, max_length=128) = Path(..., alias='LensAlias'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: LensesLensAliasVersionsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/notifications',
    description=""" List lens notifications. """,
    tags=['notification_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_notifications(
    max_results: Optional[str] = Query(None, alias='MaxResults'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: NotificationsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/shareInvitations',
    description=""" List the workload invitations. """,
    tags=['workload_operations', 'lens_version_control', 'lens_sharing_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_share_invitations(
    workload_name_prefix: Optional[constr(max_length=100)] = Query(
        None, alias='WorkloadNamePrefix'
    ),
    lens_name_prefix: Optional[constr(max_length=100)] = Query(
        None, alias='LensNamePrefix'
    ),
    share_resource_type: Optional[ShareResourceType] = Query(
        None, alias='ShareResourceType'
    ),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    max_results: Optional[conint(ge=1, le=50)] = Query(None, alias='MaxResults'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/shareInvitations/{ShareInvitationId}',
    description=""" <p>Update a workload or custom lens share invitation.</p> <note> <p>This API operation can be called independently of any resource. Previous documentation implied that a workload ARN must be specified.</p> </note> """,
    tags=['lens_sharing_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_share_invitation(
    share_invitation_id: constr(pattern=r'[0-9a-f]{32}') = Path(
        ..., alias='ShareInvitationId'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ShareInvitationsShareInvitationIdPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tags/{WorkloadArn}',
    description=""" <p>List the tags for a resource.</p> <note> <p>The WorkloadArn parameter can be either a workload ARN or a custom lens ARN.</p> </note> """,
    tags=['workload_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_tags_for_resource(
    workload_arn: str = Path(..., alias='WorkloadArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/tags/{WorkloadArn}',
    description=""" <p>Adds one or more tags to the specified resource.</p> <note> <p>The WorkloadArn parameter can be either a workload ARN or a custom lens ARN.</p> </note> """,
    tags=['workload_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def tag_resource(
    workload_arn: str = Path(..., alias='WorkloadArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: TagsWorkloadArnPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/tags/{WorkloadArn}#tagKeys',
    description=""" <p>Deletes specified tags from a resource.</p> <note> <p>The WorkloadArn parameter can be either a workload ARN or a custom lens ARN.</p> </note> <p>To specify multiple tags, use separate <b>tagKeys</b> parameters, for example:</p> <p> <code>DELETE /tags/WorkloadArn?tagKeys=key1&amp;tagKeys=key2</code> </p> """,
    tags=['workload_operations', 'notification_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def untag_resource(
    workload_arn: str = Path(..., alias='WorkloadArn'),
    tag_keys: TagKeys = Query(..., alias='tagKeys'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/workloads',
    description=""" <p>Create a new workload.</p> <p>The owner of a workload can share the workload with other Amazon Web Services accounts, users, an organization, and organizational units (OUs) in the same Amazon Web Services Region. Only the owner of a workload can delete it.</p> <p>For more information, see <a href="https://docs.aws.amazon.com/wellarchitected/latest/userguide/define-workload.html">Defining a Workload</a> in the <i>Well-Architected Tool User Guide</i>.</p> <important> <p>Either <code>AwsRegions</code>, <code>NonAwsRegions</code>, or both must be specified when creating a workload.</p> <p>You also must specify <code>ReviewOwner</code>, even though the parameter is listed as not being required in the following section. </p> </important> """,
    tags=['workload_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_workload(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: WorkloadsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/workloads/{WorkloadId}',
    description=""" Get an existing workload. """,
    tags=['workload_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_workload(
    workload_id: constr(pattern=r'[0-9a-f]{32}') = Path(..., alias='WorkloadId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/workloads/{WorkloadId}',
    description=""" Update an existing workload. """,
    tags=['workload_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_workload(
    workload_id: constr(pattern=r'[0-9a-f]{32}') = Path(..., alias='WorkloadId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: WorkloadsWorkloadIdPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/workloads/{WorkloadId}#ClientRequestToken',
    description=""" Delete an existing workload. """,
    tags=['workload_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_workload(
    workload_id: constr(pattern=r'[0-9a-f]{32}') = Path(..., alias='WorkloadId'),
    client_request_token: str = Query(..., alias='ClientRequestToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/workloads/{WorkloadId}/associateLenses',
    description=""" <p>Associate a lens to a workload.</p> <p>Up to 10 lenses can be associated with a workload in a single API operation. A maximum of 20 lenses can be associated with a workload.</p> <note> <p> <b>Disclaimer</b> </p> <p>By accessing and/or applying custom lenses created by another Amazon Web Services user or account, you acknowledge that custom lenses created by other users and shared with you are Third Party Content as defined in the Amazon Web Services Customer Agreement. </p> </note> """,
    tags=['workload_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def associate_lenses(
    workload_id: constr(pattern=r'[0-9a-f]{32}') = Path(..., alias='WorkloadId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: WorkloadsWorkloadIdAssociateLensesPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/workloads/{WorkloadId}/checkSummaries',
    description=""" List of Trusted Advisor checks summarized for all accounts related to the workload. """,
    tags=['workload_operations', 'check_summary_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_check_summaries(
    workload_id: constr(pattern=r'[0-9a-f]{32}') = Path(..., alias='WorkloadId'),
    max_results: Optional[str] = Query(None, alias='MaxResults'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: WorkloadsWorkloadIdCheckSummariesPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/workloads/{WorkloadId}/checks',
    description=""" List of Trusted Advisor check details by account related to the workload. """,
    tags=['workload_operations', 'check_summary_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_check_details(
    workload_id: constr(pattern=r'[0-9a-f]{32}') = Path(..., alias='WorkloadId'),
    max_results: Optional[str] = Query(None, alias='MaxResults'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: WorkloadsWorkloadIdChecksPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/workloads/{WorkloadId}/disassociateLenses',
    description=""" <p>Disassociate a lens from a workload.</p> <p>Up to 10 lenses can be disassociated from a workload in a single API operation.</p> <note> <p>The Amazon Web Services Well-Architected Framework lens (<code>wellarchitected</code>) cannot be removed from a workload.</p> </note> """,
    tags=['workload_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def disassociate_lenses(
    workload_id: constr(pattern=r'[0-9a-f]{32}') = Path(..., alias='WorkloadId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: WorkloadsWorkloadIdDisassociateLensesPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/workloads/{WorkloadId}/lensReviews',
    description=""" List lens reviews for a particular workload. """,
    tags=['workload_operations', 'milestone_tracking'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_lens_reviews(
    workload_id: constr(pattern=r'[0-9a-f]{32}') = Path(..., alias='WorkloadId'),
    milestone_number: Optional[conint(ge=1, le=100)] = Query(
        None, alias='MilestoneNumber'
    ),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    max_results: Optional[conint(ge=1, le=50)] = Query(None, alias='MaxResults'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/workloads/{WorkloadId}/lensReviews/{LensAlias}',
    description=""" Get lens review. """,
    tags=['lens_version_control', 'workload_operations', 'milestone_tracking'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_lens_review(
    workload_id: constr(pattern=r'[0-9a-f]{32}') = Path(..., alias='WorkloadId'),
    lens_alias: constr(min_length=1, max_length=128) = Path(..., alias='LensAlias'),
    milestone_number: Optional[conint(ge=1, le=100)] = Query(
        None, alias='MilestoneNumber'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/workloads/{WorkloadId}/lensReviews/{LensAlias}',
    description=""" Update lens review for a particular workload. """,
    tags=['lens_version_control', 'workload_operations', 'lens_review_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_lens_review(
    workload_id: constr(pattern=r'[0-9a-f]{32}') = Path(..., alias='WorkloadId'),
    lens_alias: constr(min_length=1, max_length=128) = Path(..., alias='LensAlias'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: WorkloadsWorkloadIdLensReviewsLensAliasPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/workloads/{WorkloadId}/lensReviews/{LensAlias}/answers',
    description=""" List of answers for a particular workload and lens. """,
    tags=['workload_operations', 'milestone_tracking', 'lens_version_control'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_answers(
    workload_id: constr(pattern=r'[0-9a-f]{32}') = Path(..., alias='WorkloadId'),
    lens_alias: constr(min_length=1, max_length=128) = Path(..., alias='LensAlias'),
    pillar_id: Optional[constr(min_length=1, max_length=64)] = Query(
        None, alias='PillarId'
    ),
    milestone_number: Optional[conint(ge=1, le=100)] = Query(
        None, alias='MilestoneNumber'
    ),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    max_results: Optional[conint(ge=1, le=50)] = Query(None, alias='MaxResults'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/workloads/{WorkloadId}/lensReviews/{LensAlias}/answers/{QuestionId}',
    description=""" Get the answer to a specific question in a workload review. """,
    tags=[
        'workload_operations',
        'lens_review_handling',
        'milestone_tracking',
        'answer_tracking',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_answer(
    workload_id: constr(pattern=r'[0-9a-f]{32}') = Path(..., alias='WorkloadId'),
    lens_alias: constr(min_length=1, max_length=128) = Path(..., alias='LensAlias'),
    question_id: constr(min_length=1, max_length=128) = Path(..., alias='QuestionId'),
    milestone_number: Optional[conint(ge=1, le=100)] = Query(
        None, alias='MilestoneNumber'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/workloads/{WorkloadId}/lensReviews/{LensAlias}/answers/{QuestionId}',
    description=""" Update the answer to a specific question in a workload review. """,
    tags=['lens_review_handling', 'workload_operations', 'answer_tracking'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_answer(
    workload_id: constr(pattern=r'[0-9a-f]{32}') = Path(..., alias='WorkloadId'),
    lens_alias: constr(min_length=1, max_length=128) = Path(..., alias='LensAlias'),
    question_id: constr(min_length=1, max_length=128) = Path(..., alias='QuestionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: WorkloadsWorkloadIdLensReviewsLensAliasAnswersQuestionIdPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/workloads/{WorkloadId}/lensReviews/{LensAlias}/improvements',
    description=""" List lens review improvements. """,
    tags=['workload_operations', 'milestone_tracking', 'lens_version_control'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_lens_review_improvements(
    workload_id: constr(pattern=r'[0-9a-f]{32}') = Path(..., alias='WorkloadId'),
    lens_alias: constr(min_length=1, max_length=128) = Path(..., alias='LensAlias'),
    pillar_id: Optional[constr(min_length=1, max_length=64)] = Query(
        None, alias='PillarId'
    ),
    milestone_number: Optional[conint(ge=1, le=100)] = Query(
        None, alias='MilestoneNumber'
    ),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    max_results: Optional[conint(ge=1, le=100)] = Query(None, alias='MaxResults'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/workloads/{WorkloadId}/lensReviews/{LensAlias}/report',
    description=""" Get lens review report. """,
    tags=['lens_version_control', 'milestone_tracking', 'workload_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_lens_review_report(
    workload_id: constr(pattern=r'[0-9a-f]{32}') = Path(..., alias='WorkloadId'),
    lens_alias: constr(min_length=1, max_length=128) = Path(..., alias='LensAlias'),
    milestone_number: Optional[conint(ge=1, le=100)] = Query(
        None, alias='MilestoneNumber'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/workloads/{WorkloadId}/lensReviews/{LensAlias}/upgrade',
    description=""" Upgrade lens review for a particular workload. """,
    tags=['lens_version_control', 'lens_review_handling', 'workload_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def upgrade_lens_review(
    workload_id: constr(pattern=r'[0-9a-f]{32}') = Path(..., alias='WorkloadId'),
    lens_alias: constr(min_length=1, max_length=128) = Path(..., alias='LensAlias'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: WorkloadsWorkloadIdLensReviewsLensAliasUpgradePutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/workloads/{WorkloadId}/milestones',
    description=""" Create a milestone for an existing workload. """,
    tags=['workload_operations', 'milestone_tracking'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_milestone(
    workload_id: constr(pattern=r'[0-9a-f]{32}') = Path(..., alias='WorkloadId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: WorkloadsWorkloadIdMilestonesPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/workloads/{WorkloadId}/milestones/{MilestoneNumber}',
    description=""" Get a milestone for an existing workload. """,
    tags=['workload_operations', 'milestone_tracking'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_milestone(
    workload_id: constr(pattern=r'[0-9a-f]{32}') = Path(..., alias='WorkloadId'),
    milestone_number: conint(ge=1, le=100) = Path(..., alias='MilestoneNumber'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/workloads/{WorkloadId}/milestonesSummaries',
    description=""" List all milestones for an existing workload. """,
    tags=['workload_operations', 'milestone_tracking'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_milestones(
    workload_id: constr(pattern=r'[0-9a-f]{32}') = Path(..., alias='WorkloadId'),
    max_results: Optional[str] = Query(None, alias='MaxResults'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: WorkloadsWorkloadIdMilestonesSummariesPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/workloads/{WorkloadId}/shares',
    description=""" List the workload shares associated with the workload. """,
    tags=['workload_operations', 'workload_collaboration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_workload_shares(
    workload_id: constr(pattern=r'[0-9a-f]{32}') = Path(..., alias='WorkloadId'),
    shared_with_prefix: Optional[constr(max_length=100)] = Query(
        None, alias='SharedWithPrefix'
    ),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    max_results: Optional[conint(ge=1, le=50)] = Query(None, alias='MaxResults'),
    status: Optional[Status] = Query(None, alias='Status'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/workloads/{WorkloadId}/shares',
    description=""" <p>Create a workload share.</p> <p>The owner of a workload can share it with other Amazon Web Services accounts and users in the same Amazon Web Services Region. Shared access to a workload is not removed until the workload invitation is deleted.</p> <p>If you share a workload with an organization or OU, all accounts in the organization or OU are granted access to the workload.</p> <p>For more information, see <a href="https://docs.aws.amazon.com/wellarchitected/latest/userguide/workloads-sharing.html">Sharing a workload</a> in the <i>Well-Architected Tool User Guide</i>.</p> """,
    tags=['workload_operations', 'workload_collaboration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_workload_share(
    workload_id: constr(pattern=r'[0-9a-f]{32}') = Path(..., alias='WorkloadId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: WorkloadsWorkloadIdSharesPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/workloads/{WorkloadId}/shares/{ShareId}',
    description=""" Update a workload share. """,
    tags=['workload_operations', 'lens_sharing_operations', 'workload_collaboration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_workload_share(
    share_id: constr(pattern=r'[0-9a-f]{32}') = Path(..., alias='ShareId'),
    workload_id: constr(pattern=r'[0-9a-f]{32}') = Path(..., alias='WorkloadId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: WorkloadsWorkloadIdSharesShareIdPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/workloads/{WorkloadId}/shares/{ShareId}#ClientRequestToken',
    description=""" Delete a workload share. """,
    tags=['lens_sharing_operations', 'workload_operations', 'workload_collaboration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_workload_share(
    share_id: constr(pattern=r'[0-9a-f]{32}') = Path(..., alias='ShareId'),
    workload_id: constr(pattern=r'[0-9a-f]{32}') = Path(..., alias='WorkloadId'),
    client_request_token: str = Query(..., alias='ClientRequestToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/workloadsSummaries',
    description=""" Paginated list of workloads. """,
    tags=['workload_operations', 'check_summary_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_workloads(
    max_results: Optional[str] = Query(None, alias='MaxResults'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: WorkloadsSummariesPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
